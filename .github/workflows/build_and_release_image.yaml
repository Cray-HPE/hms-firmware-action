name: Build and Publish Docker Images
on: [push, pull_request] # Question: Should this run on push/pull request? What is the value on pull_request?
jobs:
  build_and_release:
    env:
      DOCKER_REPO: cray-firmware-action
      DOCKER_REGISTRY: "artifactory.algol60.net"
      SNYK_SEVERITY: high # TODO This should be exposed as in input
      SNYK_CONTINUE_ON_ERROR: false # TODO This should be exposed as in input
      TRIVY_EXIT_CODE: 0 # TODO This should be exposed as in input
      TRIVY_SEVERITY: 'CRITICAL,HIGH' # TODO This should be exposed as in input
    name: Build and Publish Docker Images
    runs-on: ubuntu-latest #gotta access arti.dev.cray.com #${{ inputs.runs-on }} #we need self-hosted right now to get snyk. TODO try the ubuntu runner
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      #
      # Setup build environment
      #
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Login to algol60 Container Registry
        uses: docker/login-action@v1
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.ARTIFACTORY_ALGOL60_USERNAME }}
          password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}

      #
      # Build, scan, push, and sign container image
      #
      - name: Generate build suffix
        uses: Cray-HPE/hms-build-scripts/generate-build-suffix@develop
        id: build-suffix
        with:
          stable-strategy: tag

      - name: Container image tag
        id: image-tag
        shell: bash
        run: |
          # Retrieve the version from the .version file, and append the build suffix to it.
          echo "::set-output name=tag::$(cat .version)${{ steps.build-suffix.outputs.docker }}"

      # TODO if this is a stable build from a git tag, lets check that git tag matches.

      - name: Determine container image name
        id: image-name
        shell: bash
        run: |
          echo "::set-output name=name::${{ env.DOCKER_REGISTRY }}/csm-docker/${{ fromJSON(steps.build-suffix.outputs.is-stable) && 'stable' || 'unstable' }}/${{ env.DOCKER_REPO}}"

      - name: Debug 
        run: |
          echo "Container image tag: ${{ steps.image-tag.outputs.tag }}"
          echo "Container image name: ${{ steps.image-name.outputs.name }}"

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.image-name.outputs.name }}
          labels: |
            org.opencontainers.image.vendor=Hewlett Packard Enterprise Development LP
          flavor: |
            latest=false
          tags: |
            type=schedule
            type=raw,value=${{ steps.image-tag.outputs.tag }}
            type=semver,pattern={{version}},value=${{ steps.image-tag.outputs.tag }}
            type=semver,pattern={{major}}.{{minor}},value=${{ steps.image-tag.outputs.tag }}
            type=semver,pattern={{major}},value=${{ steps.image-tag.outputs.tag }}
          # Note, the {{major}}, {{major}}.{{minor}} patterns only work on git tags

      - name: Build image # Break apart build and push. Push after we scan the image. Note: Cosigning has use an image from artifactory.
        uses: docker/build-push-action@v2
        id: docker-build
        with:
          context: .
          load: true
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Current images
        run: docker images
        shell: bash

      - name: Run Snyk to check Docker images for vulnerabilities
        uses: snyk/actions/docker@master
        # TODO Revisit out how we want to handle failing synk scans. I like the idea of snyk scan failing a unstable build as that will force us to deal with it.
        # continue-on-error: ${{ !fromJSON(steps.build-suffix.outputs.is-stable) }}  # If stable build force build failure, for unstable push on.
        continue-on-error: ${{ fromJSON(env.SNYK_CONTINUE_ON_ERROR) }}
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ steps.image-name.outputs.name }}:${{ steps.image-tag.outputs.tag }}
          args: --severity-threshold=${{env.SNYK_SEVERITY}} --skip-unresolved=true

      # Note: This will always exit 0, so if a problem is found it will continue on. TODO need a policy on how to use Trivy results
      - name: Run Trivy vulnerability scanner 
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: image
          exit-code: ${{ env.TRIVY_EXIT_CODE}}
          image-ref: '${{ steps.image-name.outputs.name }}:${{ steps.image-tag.outputs.tag }}'
          severity: '${{ env.TRIVY_SEVERITY }}'
          hide-progress: false

      - name: Push image(s)
        shell: bash
        env:
          IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -eu
          for IMAGE_TAG in $IMAGE_TAGS; do
            echo "Pushing image: $IMAGE_TAG"
            docker push "$IMAGE_TAG"
          done

      - name: Sign an image in artifactory
        uses: Cray-HPE/.github/actions/csm-sign-image@v2.0-csm-sign-image
        with:
          cosign-gcp-project-id: ${{ secrets.COSIGN_GCP_PROJECT_ID }}
          cosign-gcp-sa-key: ${{ secrets.COSIGN_GCP_SA_KEY }}
          cosign-key: ${{ secrets.COSIGN_KEY }}
          registry: artifactory.algol60.net
          registry-username: ${{ secrets.ARTIFACTORY_ALGOL60_USERNAME }}
          registry-password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}
          github-sha: ${{ env.GITHUB_SHA }}
          image: ${{ steps.image-name.outputs.name }}:${{ steps.image-tag.outputs.tag }}

      - name: Generate, Attach, and Sign container image SBOM
        uses: Cray-HPE/.github/actions/csm-generate-attach-sign-sbom@v1.0-csm-generate-attach-sign-sbom
        id: sbom
        with:
          cosign-gcp-project-id: ${{ secrets.COSIGN_GCP_PROJECT_ID }}
          cosign-gcp-sa-key: ${{ secrets.COSIGN_GCP_SA_KEY }}
          cosign-key: ${{ secrets.COSIGN_KEY }}
          registry: artifactory.algol60.net
          registry-username: ${{ secrets.ARTIFACTORY_ALGOL60_USERNAME }}
          registry-password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}
          github-sha: ${{ env.GITHUB_SHA }}
          image: ${{ steps.image-name.outputs.name }}:${{ steps.image-tag.outputs.tag }}

      - name: Download artifacts
        env:
          IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
          IMAGE: ${{ steps.image-name.outputs.name }}:${{ steps.image-tag.outputs.tag }}
        run: |
          echo "Container images"
          for IMAGE_TAG in $IMAGE_TAGS; do
            echo "  Pull command: docker pull $IMAGE_TAG"
          done
          echo "Download SBOM: cosign download sbom $IMAGE > container_image.spdx"

#todos
#1 what do we do if snyk fails? an artifact has already been published?
#  - Break apart the docker/build-push-actions. 1. Build the image, 2. Scan the image, 3. Push the image
#2 need to parameterize repo and semver
#3 need to clarify the build tags we want
#  - Stable builds have 1.1.1, 1.1, 1
#  - Unstable builds have 1.1.1-12345.123
#4 need to clarify how use gets notified if synk encounters an error; does it just keep on going? or does it stop?
#  - Ryan S: My opinion is that it should cause the build to fail and not push any images.
#5 STRETCH objective : integrate SBOM
#6 where are we sending the snyk/trivy reports? Thinking about sending it to its OWN file in artifactory named: sha-digest.snky ; need to look at how the     - name: Publish Helm charts uploads and modify?